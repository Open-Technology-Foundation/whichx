#!/bin/bash
# whichx - Robust, POSIX-compliant replacement for the 'which' command
# Locates executables in PATH with enhanced features: canonical paths,
# silent mode, specific exit codes, and proper empty PATH element handling.
set -euo pipefail
shopt -s inherit_errexit extglob nullglob

declare -r VERSION=2.0
declare -r SCRIPT_NAME=${0##*/}

declare -i opt_all=0 opt_canonical=0 opt_silent=0

# Output error message to stderr (suppressed in silent mode)
error() { ((opt_silent)) || >&2 printf '%s: error: %s\n' "$SCRIPT_NAME" "$*"; }

# Display usage documentation
show_help() {
  cat <<HELP
$SCRIPT_NAME $VERSION - Locate an executable command

A robust, POSIX-compliant drop-in replacement for 'which'. Searches the PATH
environment variable and displays the location of matching executables.

Returns the pathnames of files (or links) that would be executed in the
current environment, had its arguments been given as commands in a strictly
POSIX-conformant shell.

Usage: $SCRIPT_NAME [OPTIONS] filename ...

Options:
  -a, --all        Print all matching pathnames (not just first match)
  -c, --canonical  Resolve symlinks and print canonical paths via realpath
  -s, --silent     Suppress all output; communicate via exit code only
  -V, --version    Print version and exit
  -h, --help       Display this help and exit

Exit Codes:
  0   All specified commands found
  1   One or more commands not found
  2   Usage error (no arguments provided)
  22  Invalid option (EINVAL)

Examples:
  $SCRIPT_NAME ls                    # Find location of ls
  $SCRIPT_NAME ls cat grep           # Find multiple commands
  $SCRIPT_NAME -a python3            # Show all python3 in PATH
  $SCRIPT_NAME -c vim                # Canonical path (resolve symlinks)
  $SCRIPT_NAME -ac python3           # Combined: all matches, canonical
  $SCRIPT_NAME -s gcc make || exit 1 # Pre-flight check in scripts

Requirements:
  bash 4.4+, realpath

See also: which(1), whereis(1), type(1), command(1)
HELP
}

# Output path to stdout, optionally resolving to canonical form
# Returns: 0 on success, 1 if realpath fails (canonical mode only)
get_path() {
  local -- path=$1
  if ((opt_canonical)); then
    if ! path=$(realpath -- "$path" 2>/dev/null); then
      error "Cannot resolve canonical path for ${1@Q}"
      return 1
    fi
  fi
  ((opt_silent)) || printf '%s\n' "$path"
  return 0
}

# Search for executable in PATH directories
# Handles both simple names (searched in PATH) and path-containing names (used directly)
# Returns: 0 if found, 1 if not found
search_executable() {
  local -- program=$1
  local -- path full_path
  local -i found=0

  # Path-containing names bypass PATH search (absolute/relative paths)
  if [[ $program == */* ]]; then
    if [[ -f $program && -x $program ]]; then
      #shellcheck disable=SC2015
      get_path "$program" && found=1 ||:
    fi
    return $((found ? 0 : 1))
  fi

  # Split PATH into array using colon delimiter (POSIX standard)
  local -- IFS=':'
  local -a path_dirs
  read -ra path_dirs <<< "${PATH:-}"
  local -- path
  for path in "${path_dirs[@]}"; do
    # Empty PATH elements mean current directory per POSIX (e.g., PATH=":/usr/bin")
    [[ -n $path ]] || path='.'

    full_path="$path"/"$program"

    # Check if file exists and is executable
    if [[ -f $full_path && -x $full_path ]]; then
      if get_path "$full_path"; then
        found=1
        # If not showing all matches, stop after first match
        ((opt_all)) || break
      fi
    fi
  done

  return $((found ? 0 : 1))
}

# Main entry point: parse arguments, search for each target, return aggregate status
main() {
  local -i overall_exit_code=0
  local -a targets=()
  local -- target

  # Argument parsing with combined short option support (-ac → -a -c)
  while (($#)); do
    case $1 in
      -a|--all)       opt_all=1
                      ;;
      -c|--canonical) opt_canonical=1
                      ;;
      -s|--silent)    opt_silent=1
                      ;;
      -V|--version)   printf '%s %s\n' "$SCRIPT_NAME" "$VERSION"
                      return 0
                      ;;
      -h|--help)      show_help
                      return 0
                      ;;
      --)             shift
                      targets+=("$@")
                      break
                      ;;  # End of options
      -[acsVh]?*)  # Combined short options (2+ chars): -ac → -a -c
                      set -- "${1:0:2}" "-${1:2}" "${@:2}"
                      ;;
      -*)             error "Illegal option ${1@Q}"
                      exit 22
                      ;;
      *)              targets+=("$1")
                      ;;
    esac
    shift
  done

  # Require at least one target filename
  if ((${#targets[@]} == 0)); then
    ((opt_silent)) || error "No arguments provided. See $SCRIPT_NAME --help"
    exit 2
  fi

  # Search each target; overall success only if ALL targets found
  for target in "${targets[@]}"; do
    search_executable "$target" || overall_exit_code=1
  done

  exit $overall_exit_code
}

main "$@"
#fin
