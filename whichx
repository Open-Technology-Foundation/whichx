#!/bin/bash
# whichx - Robust, POSIX-compliant replacement for the 'which' command
# Locates executables in PATH with enhanced features: canonical paths,
# silent mode, specific exit codes, and proper empty PATH element handling.
set -euo pipefail
shopt -s inherit_errexit extglob nullglob

declare -r VERSION=2.0

#shellcheck disable=SC2155
declare -r SCRIPT_PATH=$(realpath -e -- "$0")
#shellcheck disable=SC2034  # SCRIPT_DIR reserved for BCS compliance
declare -r SCRIPT_DIR=${SCRIPT_PATH%/*}
declare -r SCRIPT_NAME=${SCRIPT_PATH##*/}

# Exit codes
declare -ir EXIT_SUCCESS=0 EXIT_NOT_FOUND=1 EXIT_USAGE_ERROR=2 EXIT_INVALID_OPTION=22

declare -i opt_all=0 opt_canonical=0 opt_silent=0
declare -a targets=()

# Display usage documentation
show_help() {
  cat <<EOT
$SCRIPT_NAME $VERSION - Locate a command

A robust, POSIX-compliant drop-in replacement for 'which'. Searches the PATH
environment variable and displays the location of matching executables.

Returns the pathnames of files (or links) that would be executed in the
current environment, had its arguments been given as commands in a strictly
POSIX-conformant shell.

Usage: $SCRIPT_NAME [OPTIONS] filename ...

Options:
  -a, --all        Print all matching pathnames (not just first match)
  -c, --canonical  Resolve symlinks and print canonical paths via realpath
  -s, --silent     Suppress all output; communicate via exit code only
  -V, --version    Print version and exit
  -h, --help       Display this help and exit

Exit Codes:
  0   All specified commands found
  1   One or more commands not found
  2   Usage error (no arguments provided)
  22  Invalid option (EINVAL)

Examples:
  $SCRIPT_NAME ls                    # Find location of ls
  $SCRIPT_NAME ls cat grep           # Find multiple commands
  $SCRIPT_NAME -a python3            # Show all python3 in PATH
  $SCRIPT_NAME -c vim                # Canonical path (resolve symlinks)
  $SCRIPT_NAME -ac python3           # Combined: all matches, canonical
  $SCRIPT_NAME -s gcc make || exit 1 # Pre-flight check in scripts

Requirements:
  bash 4.3+, realpath, grep

See also: which(1), whereis(1), type(1), command(1)
EOT
}

# Output error message to stderr (suppressed in silent mode)
error() { ((opt_silent)) || >&2 printf '%s: ✗ %s\n' "$SCRIPT_NAME" "$*"; }

# Output path to stdout, optionally resolving to canonical form
# Returns: 0 on success, 1 if realpath fails (canonical mode only)
get_path() {
  local -- path=$1

  if ((opt_canonical)); then
    if ! realpath -- "$path" 2>/dev/null; then
      error "Cannot resolve canonical path for ${path@Q}"
      return 1
    fi
  else
    ((opt_silent)) || printf '%s\n' "$path"
  fi
  return 0
}

# Search for executable in PATH directories
# Handles both simple names (searched in PATH) and path-containing names (used directly)
# Returns: 0 if found, 1 if not found
search_executable() {
  local -- program=$1 path full_path
  local -i found=0

  # Path-containing names bypass PATH search (absolute/relative paths)
  if [[ $program == */* ]]; then
    if [[ -f $program && -x $program ]]; then
      get_path "$program" && found=1 ||:
    fi
    return $((found ? 0 : 1))
  fi

  # Split PATH into array using colon delimiter (POSIX standard)
  local IFS=':'
  local -a path_dirs
  read -ra path_dirs <<< "${PATH:-}"

  for path in "${path_dirs[@]}"; do
    # Empty PATH elements mean current directory per POSIX (e.g., PATH=":/usr/bin")
    [[ -n $path ]] || path='.'

    full_path="$path/$program"

    # Check if file exists and is executable
    if [[ -f $full_path && -x $full_path ]]; then
      if get_path "$full_path"; then
        found=1
        # If not showing all matches, stop after first match
        ((opt_all)) || break
      fi
    fi
  done

  return $((found ? 0 : 1))
}

# Main entry point: parse arguments, search for each target, return aggregate status
main() {
  local -i overall_exit_code=$EXIT_SUCCESS
  local -- target

  # Argument parsing with combined short option support (-ac → -a -c)
  while (($#)); do
    case $1 in
      -a|--all)       opt_all=1 ;;
      -c|--canonical) opt_canonical=1 ;;
      -s|--silent)    opt_silent=1 ;;
      -V|--version)   echo "$SCRIPT_NAME $VERSION"; return $EXIT_SUCCESS ;;
      -h|--help)      show_help; return $EXIT_SUCCESS ;;
      --)             shift; targets+=("$@"); break ;;  # End of options
      -[acsVh]*) #shellcheck disable=SC2046  # Split combined options: -ac → -a -c
                      set -- '' $(printf -- '-%c ' $(grep -o . <<<"${1:1}")) "${@:2}" ;;
      -*)             error "Invalid option ${1@Q}"; exit $EXIT_INVALID_OPTION ;;
      *)              targets+=("$1") ;;
    esac
    shift
  done

  # Require at least one target filename
  if ((${#targets[@]} == 0)); then
    ((opt_silent)) || error "No arguments provided. See $SCRIPT_NAME --help"
    exit $EXIT_USAGE_ERROR
  fi

  # Search each target; overall success only if ALL targets found
  for target in "${targets[@]}"; do
    if ! search_executable "$target"; then
      overall_exit_code=$EXIT_NOT_FOUND
    fi
  done

  exit $overall_exit_code
}

main "$@"
#fin
