#!/bin/bash
# SPDX-License-Identifier: GPL-3.0-or-later
# Copyright (C) 2025 Indonesian Open Technology Foundation (admin@yatti.id)
# whichx - Locate executables in PATH
set -euo pipefail
shopt -s inherit_errexit

declare -r VERSION=2.0
declare -r SCRIPT_NAME=${0##*/}

declare -i opt_all=0 opt_canonical=0 opt_silent=0

error() { ((opt_silent)) || >&2 printf '%s: error: %s\n' "$SCRIPT_NAME" "$*"; }

# realpath preferred, readlink -f fallback
resolve_path() { realpath -- "$1" 2>/dev/null || readlink -f -- "$1" 2>/dev/null; }

show_help() {
  cat <<HELP
$SCRIPT_NAME $VERSION - Locate executables in PATH

Usage: $SCRIPT_NAME [OPTIONS] [--] command ...

Options:
  -a, --all        Print all matches, not just first
  -c, --canonical  Resolve symlinks via realpath/readlink
  -q, --quiet      No output, exit code only
  -s, --silent     Same as -q
  -V, --version    Print version
  -h, --help       This help

Exit: 0=found, 1=not found, 2=no args, 22=bad option

Examples:
  $SCRIPT_NAME ls
  $SCRIPT_NAME -a python3
  $SCRIPT_NAME -c vim
  $SCRIPT_NAME -q gcc || exit 1
HELP
}

# Print path (canonical if -c), respects -q
get_path() {
  local -- path=$1
  if ((opt_canonical)); then
    if ! path=$(resolve_path "$path"); then
      error "Cannot resolve canonical path for ${1@Q}"
      return 1
    fi
  fi
  ((opt_silent)) || printf '%s\n' "$path"
  return 0
}

# Search PATH for executable; paths with / bypass PATH search
search_executable() {
  local -- program=$1
  local -- path full_path
  local -i found=0

  if [[ $program == */* ]]; then
    if [[ -f $program && -x $program ]]; then
      ! get_path "$program" || found=1
    fi
    return $((found ? 0 : 1))
  fi

  local -- IFS=':'
  local -a path_dirs
  read -ra path_dirs <<< "${PATH:-}"
  for path in "${path_dirs[@]}"; do
    [[ -n $path ]] || path='.'  # Empty element = cwd (POSIX)

    full_path="${path%/}"/"$program"

    if [[ -f $full_path && -x $full_path ]]; then
      if get_path "$full_path"; then
        found=1
        ((opt_all)) || break
      fi
    fi
  done

  return $((found ? 0 : 1))
}

main() {
  local -i overall_exit_code=0
  local -a targets=()
  local -- target

  while (($#)); do
    case $1 in
      -a|--all)       opt_all=1 ;;
      -c|--canonical) opt_canonical=1 ;;
      -q|--quiet|-s|--silent)
                      opt_silent=1 ;;
      -V|--version)   printf '%s %s\n' "$SCRIPT_NAME" "$VERSION"
                      return 0 ;;
      -h|--help)      show_help
                      return 0 ;;
      --)             shift; targets+=("$@"); break ;;
      -[acqsVh]?*)    set -- "${1:0:2}" "-${1:2}" "${@:2}"; continue ;;
      -*)             error "Illegal option ${1@Q}"; exit 22 ;;
      *)              targets+=("$1") ;;
    esac
    shift
  done

  if ((${#targets[@]} == 0)); then
    ((opt_silent)) || error "No arguments. See $SCRIPT_NAME --help"
    exit 2
  fi

  for target in "${targets[@]}"; do
    search_executable "$target" || overall_exit_code=1
  done

  exit $overall_exit_code
}

main "$@"
#fin
